// routes/eldenring.js
const express = require('express');
const router = express.Router();
const { ensureAuthenticated } = require('../config/passport');
const db = require('../config/db'); // Assumindo que 'db' exporta o Pool do pg

// --- ROTA GET Principal para /game/elden-ring ---
router.get('/', ensureAuthenticated, async (req, res, next) => {
    try {
        const userId = req.user.user_id;
        // Queries do Promise.all (sem alterações aqui, assumindo que os nomes das colunas estão corretos agora)
        const [ mapAreasResult, gracesResult, bossesResult, merchantsResult, enemiesResult, itemsResult ] = await Promise.all([
            db.query('SELECT * FROM elden_ring_map_areas WHERE user_id = $1 ORDER BY area_name', [userId]),
            db.query('SELECT g.*, a.area_name FROM elden_ring_graces g LEFT JOIN elden_ring_map_areas a ON g.map_area_id = a.area_id WHERE g.user_id = $1 ORDER BY g.grace_name', [userId]),
            db.query(`SELECT b.*, a.area_name, gr.grace_name, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('item_id', i.item_id, 'item_name', i.item_name)) FILTER (WHERE i.item_id IS NOT NULL), '[]'::jsonb) AS dropped_items FROM elden_ring_bosses b LEFT JOIN elden_ring_map_areas a ON b.map_area_id = a.area_id AND a.user_id = $1 LEFT JOIN elden_ring_graces gr ON b.nearest_grace_id = gr.grace_id AND gr.user_id = $1 LEFT JOIN elden_ring_boss_drops bd ON b.boss_id = bd.boss_id LEFT JOIN elden_ring_items i ON bd.item_id = i.item_id AND i.user_id = $1 WHERE b.user_id = $1 GROUP BY b.boss_id, a.area_name, gr.grace_name ORDER BY b.boss_name`, [userId]),
            db.query(`SELECT m.*, a.area_name, gr.grace_name, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('item_id', i.item_id, 'item_name', i.item_name)) FILTER (WHERE i.item_id IS NOT NULL), '[]'::jsonb) AS inventory FROM elden_ring_merchants m LEFT JOIN elden_ring_map_areas a ON m.map_area_id = a.area_id AND a.user_id = $1 LEFT JOIN elden_ring_graces gr ON m.nearest_grace_id = gr.grace_id AND gr.user_id = $1 LEFT JOIN elden_ring_merchant_inventory mi ON m.merchant_id = mi.merchant_id LEFT JOIN elden_ring_items i ON mi.item_id = i.item_id AND i.user_id = $1 WHERE m.user_id = $1 GROUP BY m.merchant_id, a.area_name, gr.grace_name ORDER BY m.merchant_name`, [userId]),
            db.query(`SELECT e.*, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('area_id', a.area_id, 'area_name', a.area_name)) FILTER (WHERE a.area_id IS NOT NULL), '[]'::jsonb) AS locations, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('item_id', i.item_id, 'item_name', i.item_name)) FILTER (WHERE i.item_id IS NOT NULL), '[]'::jsonb) AS dropped_items FROM elden_ring_enemies e LEFT JOIN elden_ring_enemy_locations el ON e.enemy_id = el.enemy_id LEFT JOIN elden_ring_map_areas a ON el.map_area_id = a.area_id AND a.user_id = $1 LEFT JOIN elden_ring_enemy_drops ed ON e.enemy_id = ed.enemy_id LEFT JOIN elden_ring_items i ON ed.item_id = i.item_id AND i.user_id = $1 WHERE e.user_id = $1 GROUP BY e.enemy_id ORDER BY e.enemy_name`, [userId]),
            db.query(`SELECT it.*, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('area_id', la.area_id, 'area_name', la.area_name)) FILTER (WHERE la.area_id IS NOT NULL), '[]'::jsonb) AS locations, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('boss_id', b.boss_id, 'boss_name', b.boss_name)) FILTER (WHERE b.boss_id IS NOT NULL), '[]'::jsonb) AS dropped_by_bosses, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('enemy_id', en.enemy_id, 'enemy_name', en.enemy_name)) FILTER (WHERE en.enemy_id IS NOT NULL), '[]'::jsonb) AS dropped_by_enemies, COALESCE(jsonb_agg(DISTINCT jsonb_build_object('merchant_id', m.merchant_id, 'merchant_name', m.merchant_name)) FILTER (WHERE m.merchant_id IS NOT NULL), '[]'::jsonb) AS sold_by_merchants FROM elden_ring_items it LEFT JOIN elden_ring_item_locations il ON it.item_id = il.item_id LEFT JOIN elden_ring_map_areas la ON il.map_area_id = la.area_id AND la.user_id = $1 LEFT JOIN elden_ring_boss_drops bd ON it.item_id = bd.item_id LEFT JOIN elden_ring_bosses b ON bd.boss_id = b.boss_id AND b.user_id = $1 LEFT JOIN elden_ring_enemy_drops ed ON it.item_id = ed.item_id LEFT JOIN elden_ring_enemies en ON ed.enemy_id = en.enemy_id AND en.user_id = $1 LEFT JOIN elden_ring_merchant_inventory mi ON it.item_id = mi.item_id LEFT JOIN elden_ring_merchants m ON mi.merchant_id = m.merchant_id AND m.user_id = $1 WHERE it.user_id = $1 GROUP BY it.item_id ORDER BY it.item_name`, [userId])
        ]);

        const mapAreas = mapAreasResult.rows; const graces = gracesResult.rows; const bosses = bossesResult.rows; const merchants = merchantsResult.rows; const enemies = enemiesResult.rows; const items = itemsResult.rows;
        const overviewData = mapAreas.map(area => ({ area_id: area.area_id, area_name: area.area_name, notes: area.notes, graces: graces.filter(g => g.map_area_id === area.area_id).map(g => ({ grace_id: g.grace_id, grace_name: g.grace_name })), bosses: bosses.filter(b => b.map_area_id === area.area_id).map(b => ({ boss_id: b.boss_id, boss_name: b.boss_name })), merchants: merchants.filter(m => m.map_area_id === area.area_id).map(m => ({ merchant_id: m.merchant_id, merchant_name: m.merchant_name })) }));

        res.render('game/eldenring/eldenring', { pageTitle: 'Elden Ring Tracker', user: req.user, overviewData, mapAreas, graces, bosses, merchants, enemies, items, messages: req.flash() });
    } catch (err) { console.error("Erro Rota GET /game/elden-ring:", err); next(err); }
});

// --- ROTAS POST (ADD) ---
router.post('/map-areas', ensureAuthenticated, async (req, res, next) => { /* ... sem getClient ... */ try { const { area_name, notes } = req.body; const userId = req.user.user_id; await db.query('INSERT INTO elden_ring_map_areas (user_id, area_name, notes) VALUES ($1, $2, $3)', [userId, area_name, notes]); req.flash('success_msg', `Map Area "${area_name}" added.`); res.redirect('/game/elden-ring#map-areas-section'); } catch (err) { console.error("Erro add Map Area:", err); req.flash('error_msg', 'Failed to add Map Area.'); next(err); } });
router.post('/graces', ensureAuthenticated, async (req, res, next) => { /* ... sem getClient ... */ try { const { grace_name, map_area_id, notes } = req.body; const userId = req.user.user_id; await db.query('INSERT INTO elden_ring_graces (user_id, grace_name, map_area_id, notes) VALUES ($1, $2, $3, $4)', [userId, grace_name, map_area_id || null, notes]); req.flash('success_msg', `Site of Grace "${grace_name}" added.`); res.redirect('/game/elden-ring#graces-section'); } catch (err) { console.error("Erro add Grace:", err); req.flash('error_msg', 'Failed to add Site of Grace.'); next(err); } });
router.post('/bosses', ensureAuthenticated, async (req, res, next) => { const { boss_name, map_area_id, nearest_grace_id, notes, is_defeated } = req.body; let { dropped_item_ids } = req.body; const userId = req.user.user_id; if (typeof dropped_item_ids === 'string') dropped_item_ids = [dropped_item_ids]; else if (typeof dropped_item_ids === 'undefined') dropped_item_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); const bossResult = await client.query('INSERT INTO elden_ring_bosses (user_id, boss_name, map_area_id, nearest_grace_id, notes, is_defeated) VALUES ($1, $2, $3, $4, $5, $6) RETURNING boss_id', [userId, boss_name, map_area_id || null, nearest_grace_id || null, notes, !!is_defeated]); const bossId = bossResult.rows[0].boss_id; if (dropped_item_ids.length > 0) { const dropValues = dropped_item_ids.map(itemId => `(${bossId}, ${parseInt(itemId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_boss_drops (boss_id, item_id) VALUES ${dropValues}`); } await client.query('COMMIT'); req.flash('success_msg', `Boss "${boss_name}" added.`); res.redirect('/game/elden-ring#bosses-section'); } catch (err) { await client.query('ROLLBACK'); console.error("Erro add Boss:", err); req.flash('error_msg', 'Failed to add Boss.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });
router.post('/enemies', ensureAuthenticated, async (req, res, next) => { const { enemy_name, notes } = req.body; let { location_area_ids, dropped_item_ids } = req.body; const userId = req.user.user_id; if (typeof location_area_ids === 'string') location_area_ids = [location_area_ids]; else if (typeof location_area_ids === 'undefined') location_area_ids = []; if (typeof dropped_item_ids === 'string') dropped_item_ids = [dropped_item_ids]; else if (typeof dropped_item_ids === 'undefined') dropped_item_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); const enemyResult = await client.query('INSERT INTO elden_ring_enemies (user_id, enemy_name, notes) VALUES ($1, $2, $3) RETURNING enemy_id', [userId, enemy_name, notes]); const enemyId = enemyResult.rows[0].enemy_id; if (location_area_ids.length > 0) { const locationValues = location_area_ids.map(areaId => `(${enemyId}, ${parseInt(areaId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_enemy_locations (enemy_id, map_area_id) VALUES ${locationValues}`); /* <-- Corrigido nome coluna aqui também */ } if (dropped_item_ids.length > 0) { const dropValues = dropped_item_ids.map(itemId => `(${enemyId}, ${parseInt(itemId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_enemy_drops (enemy_id, item_id) VALUES ${dropValues}`); } await client.query('COMMIT'); req.flash('success_msg', `Enemy "${enemy_name}" added.`); res.redirect('/game/elden-ring#enemies-section'); } catch (err) { await client.query('ROLLBACK'); console.error("Erro add Enemy:", err); req.flash('error_msg', 'Failed to add Enemy.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });
router.post('/merchants', ensureAuthenticated, async (req, res, next) => { const { merchant_name, map_area_id, nearest_grace_id, notes } = req.body; let { inventory_item_ids } = req.body; const userId = req.user.user_id; if (typeof inventory_item_ids === 'string') inventory_item_ids = [inventory_item_ids]; else if (typeof inventory_item_ids === 'undefined') inventory_item_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); const merchantResult = await client.query('INSERT INTO elden_ring_merchants (user_id, merchant_name, map_area_id, nearest_grace_id, notes) VALUES ($1, $2, $3, $4, $5) RETURNING merchant_id', [userId, merchant_name, map_area_id || null, nearest_grace_id || null, notes]); const merchantId = merchantResult.rows[0].merchant_id; if (inventory_item_ids.length > 0) { const inventoryValues = inventory_item_ids.map(itemId => `(${merchantId}, ${parseInt(itemId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_merchant_inventory (merchant_id, item_id) VALUES ${inventoryValues}`); } await client.query('COMMIT'); req.flash('success_msg', `Merchant "${merchant_name}" added.`); res.redirect('/game/elden-ring#merchants-section'); } catch (err) { await client.query('ROLLBACK'); console.error("Erro add Merchant:", err); req.flash('error_msg', 'Failed to add Merchant.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });
router.post('/items', ensureAuthenticated, async (req, res, next) => { const { item_name, item_type, notes, is_obtained } = req.body; let { location_area_ids } = req.body; const userId = req.user.user_id; if (typeof location_area_ids === 'string') location_area_ids = [location_area_ids]; else if (typeof location_area_ids === 'undefined') location_area_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); const itemResult = await client.query('INSERT INTO elden_ring_items (user_id, item_name, item_type, notes, is_obtained) VALUES ($1, $2, $3, $4, $5) RETURNING item_id', [userId, item_name, item_type || null, notes, !!is_obtained]); const itemId = itemResult.rows[0].item_id; if (location_area_ids.length > 0) { const locationValues = location_area_ids.map(areaId => `(${itemId}, ${parseInt(areaId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_item_locations (item_id, map_area_id) VALUES ${locationValues}`); /* <-- Corrigido nome coluna aqui também */ } await client.query('COMMIT'); req.flash('success_msg', `Item "${item_name}" added.`); res.redirect('/game/elden-ring#items-section'); } catch (err) { await client.query('ROLLBACK'); console.error("Erro add Item:", err); req.flash('error_msg', 'Failed to add Item.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });

// --- ROTAS PUT (UPDATE) ---
router.put('/map-areas/:id', ensureAuthenticated, async (req, res, next) => { /* ... sem getClient ... */ try { const { area_name, notes } = req.body; const areaId = req.params.id; const userId = req.user.user_id; await db.query('UPDATE elden_ring_map_areas SET area_name = $1, notes = $2 WHERE area_id = $3 AND user_id = $4', [area_name, notes, areaId, userId]); req.flash('success_msg', `Map Area "${area_name}" updated.`); res.redirect('/game/elden-ring#map-areas-section'); } catch (err) { console.error(`Erro update Map Area ${areaId}:`, err); req.flash('error_msg', 'Failed to update Map Area.'); next(err); } });
router.put('/graces/:id', ensureAuthenticated, async (req, res, next) => { /* ... sem getClient ... */ try { const { grace_name, map_area_id, notes } = req.body; const graceId = req.params.id; const userId = req.user.user_id; await db.query('UPDATE elden_ring_graces SET grace_name = $1, map_area_id = $2, notes = $3 WHERE grace_id = $4 AND user_id = $5', [grace_name, map_area_id || null, notes, graceId, userId]); req.flash('success_msg', `Site of Grace "${grace_name}" updated.`); res.redirect('/game/elden-ring#graces-section'); } catch (err) { console.error(`Erro update Grace ${graceId}:`, err); req.flash('error_msg', 'Failed to update Site of Grace.'); next(err); } });
router.put('/bosses/:id', ensureAuthenticated, async (req, res, next) => { const { boss_name, map_area_id, nearest_grace_id, notes, is_defeated } = req.body; let { dropped_item_ids } = req.body; const bossId = req.params.id; const userId = req.user.user_id; if (typeof dropped_item_ids === 'string') dropped_item_ids = [dropped_item_ids]; else if (typeof dropped_item_ids === 'undefined') dropped_item_ids = []; const defeatedBool = !!is_defeated; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('UPDATE elden_ring_bosses SET boss_name = $1, map_area_id = $2, nearest_grace_id = $3, notes = $4, is_defeated = $5 WHERE boss_id = $6 AND user_id = $7', [boss_name, map_area_id || null, nearest_grace_id || null, notes, defeatedBool, bossId, userId]); await client.query('DELETE FROM elden_ring_boss_drops WHERE boss_id = $1', [bossId]); if (dropped_item_ids.length > 0) { const dropValues = dropped_item_ids.map(itemId => `(${bossId}, ${parseInt(itemId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_boss_drops (boss_id, item_id) VALUES ${dropValues}`); } await client.query('COMMIT'); req.flash('success_msg', `Boss "${boss_name}" updated.`); res.redirect('/game/elden-ring#bosses-section'); } catch (err) { await client.query('ROLLBACK'); console.error(`Erro update Boss ${bossId}:`, err); req.flash('error_msg', 'Failed to update Boss.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });
router.put('/enemies/:id', ensureAuthenticated, async (req, res, next) => { const { enemy_name, notes } = req.body; let { location_area_ids, dropped_item_ids } = req.body; const enemyId = req.params.id; const userId = req.user.user_id; if (typeof location_area_ids === 'string') location_area_ids = [location_area_ids]; else if (typeof location_area_ids === 'undefined') location_area_ids = []; if (typeof dropped_item_ids === 'string') dropped_item_ids = [dropped_item_ids]; else if (typeof dropped_item_ids === 'undefined') dropped_item_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('UPDATE elden_ring_enemies SET enemy_name = $1, notes = $2 WHERE enemy_id = $3 AND user_id = $4', [enemy_name, notes, enemyId, userId]); await client.query('DELETE FROM elden_ring_enemy_locations WHERE enemy_id = $1', [enemyId]); if (location_area_ids.length > 0) { const locationValues = location_area_ids.map(areaId => `(${enemyId}, ${parseInt(areaId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_enemy_locations (enemy_id, map_area_id) VALUES ${locationValues}`); /* <-- Corrigido nome coluna aqui também */ } await client.query('DELETE FROM elden_ring_enemy_drops WHERE enemy_id = $1', [enemyId]); if (dropped_item_ids.length > 0) { const dropValues = dropped_item_ids.map(itemId => `(${enemyId}, ${parseInt(itemId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_enemy_drops (enemy_id, item_id) VALUES ${dropValues}`); } await client.query('COMMIT'); req.flash('success_msg', `Enemy "${enemy_name}" updated.`); res.redirect('/game/elden-ring#enemies-section'); } catch (err) { await client.query('ROLLBACK'); console.error(`Erro update Enemy ${enemyId}:`, err); req.flash('error_msg', 'Failed to update Enemy.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });
router.put('/merchants/:id', ensureAuthenticated, async (req, res, next) => { const { merchant_name, map_area_id, nearest_grace_id, notes } = req.body; let { inventory_item_ids } = req.body; const merchantId = req.params.id; const userId = req.user.user_id; if (typeof inventory_item_ids === 'string') inventory_item_ids = [inventory_item_ids]; else if (typeof inventory_item_ids === 'undefined') inventory_item_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); const updateResult = await client.query('UPDATE elden_ring_merchants SET merchant_name = $1, map_area_id = $2, nearest_grace_id = $3, notes = $4 WHERE merchant_id = $5 AND user_id = $6', [merchant_name, map_area_id || null, nearest_grace_id || null, notes, merchantId, userId]); if (updateResult.rowCount === 0) { throw new Error('Merchant not found or user mismatch.'); } await client.query('DELETE FROM elden_ring_merchant_inventory WHERE merchant_id = $1', [merchantId]); if (inventory_item_ids.length > 0) { const inventoryValues = inventory_item_ids.map(itemId => `(${merchantId}, ${parseInt(itemId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_merchant_inventory (merchant_id, item_id) VALUES ${inventoryValues}`); } await client.query('COMMIT'); req.flash('success_msg', `Merchant "${merchant_name}" updated.`); res.redirect('/game/elden-ring#merchants-section'); } catch (err) { await client.query('ROLLBACK'); console.error(`[Merchant Update Error] ID=${merchantId}:`, err); req.flash('error_msg', `Failed to update merchant. ${err.message}`); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });
router.put('/items/:id', ensureAuthenticated, async (req, res, next) => { const { item_name, item_type, notes, is_obtained } = req.body; let { location_area_ids } = req.body; const itemId = req.params.id; const userId = req.user.user_id; const obtainedBool = !!is_obtained; if (typeof location_area_ids === 'string') location_area_ids = [location_area_ids]; else if (typeof location_area_ids === 'undefined') location_area_ids = []; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('UPDATE elden_ring_items SET item_name = $1, item_type = $2, notes = $3, is_obtained = $4 WHERE item_id = $5 AND user_id = $6', [item_name, item_type || null, notes, obtainedBool, itemId, userId]); await client.query('DELETE FROM elden_ring_item_locations WHERE item_id = $1', [itemId]); if (location_area_ids.length > 0) { const locationValues = location_area_ids.map(areaId => `(${itemId}, ${parseInt(areaId, 10)})`).join(','); await client.query(`INSERT INTO elden_ring_item_locations (item_id, map_area_id) VALUES ${locationValues}`); /* <-- Corrigido nome coluna aqui também */ } await client.query('COMMIT'); req.flash('success_msg', `Item "${item_name}" updated.`); res.redirect('/game/elden-ring#items-section'); } catch (err) { await client.query('ROLLBACK'); console.error(`Erro update Item ${itemId}:`, err); req.flash('error_msg', 'Failed to update Item.'); next(err); } finally { client.release(); /* <-- GARANTIDO */ } });

// --- ROTAS DELETE ---
router.delete('/map-areas/:id', ensureAuthenticated, async (req, res) => { /* ... sem getClient ... */ try { const areaId = req.params.id; const userId = req.user.user_id; const result = await db.query('DELETE FROM elden_ring_map_areas WHERE area_id = $1 AND user_id = $2', [areaId, userId]); if (result.rowCount > 0) { res.sendStatus(200); } else { res.status(404).json({ error: 'Map Area not found or not owned by user.' }); } } catch (err) { console.error(`Erro delete Map Area ${areaId}:`, err); res.status(500).json({ error: 'Failed to delete Map Area.' }); } });
router.delete('/graces/:id', ensureAuthenticated, async (req, res) => { /* ... sem getClient ... */ try { const graceId = req.params.id; const userId = req.user.user_id; const result = await db.query('DELETE FROM elden_ring_graces WHERE grace_id = $1 AND user_id = $2', [graceId, userId]); if (result.rowCount > 0) { res.sendStatus(200); } else { res.status(404).json({ error: 'Grace not found or not owned by user.' }); } } catch (err) { console.error(`Erro delete Grace ${graceId}:`, err); res.status(500).json({ error: 'Failed to delete Site of Grace.' }); } });
router.delete('/bosses/:id', ensureAuthenticated, async (req, res) => { const bossId = req.params.id; const userId = req.user.user_id; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('DELETE FROM elden_ring_boss_drops WHERE boss_id = $1', [bossId]); const result = await client.query('DELETE FROM elden_ring_bosses WHERE boss_id = $1 AND user_id = $2', [bossId, userId]); await client.query('COMMIT'); if (result.rowCount > 0) { res.sendStatus(200); } else { await client.query('ROLLBACK'); res.status(404).json({ error: 'Boss not found or not owned by user.' }); } } catch (err) { await client.query('ROLLBACK'); console.error(`Erro delete Boss ${bossId}:`, err); res.status(500).json({ error: 'Failed to delete Boss.' }); } finally { client.release(); /* <-- GARANTIDO */ } });
router.delete('/enemies/:id', ensureAuthenticated, async (req, res) => { const enemyId = req.params.id; const userId = req.user.user_id; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('DELETE FROM elden_ring_enemy_locations WHERE enemy_id = $1', [enemyId]); await client.query('DELETE FROM elden_ring_enemy_drops WHERE enemy_id = $1', [enemyId]); const result = await client.query('DELETE FROM elden_ring_enemies WHERE enemy_id = $1 AND user_id = $2', [enemyId, userId]); await client.query('COMMIT'); if (result.rowCount > 0) { res.sendStatus(200); } else { await client.query('ROLLBACK'); res.status(404).json({ error: 'Enemy not found or not owned by user.' }); } } catch (err) { await client.query('ROLLBACK'); console.error(`Erro delete Enemy ${enemyId}:`, err); res.status(500).json({ error: 'Failed to delete Enemy.' }); } finally { client.release(); /* <-- GARANTIDO */ } });
router.delete('/merchants/:id', ensureAuthenticated, async (req, res) => { const merchantId = req.params.id; const userId = req.user.user_id; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('DELETE FROM elden_ring_merchant_inventory WHERE merchant_id = $1', [merchantId]); const result = await client.query('DELETE FROM elden_ring_merchants WHERE merchant_id = $1 AND user_id = $2', [merchantId, userId]); await client.query('COMMIT'); if (result.rowCount > 0) { res.sendStatus(200); } else { await client.query('ROLLBACK'); res.status(404).json({ error: 'Merchant not found or not owned by user.' }); } } catch (err) { await client.query('ROLLBACK'); console.error(`Erro delete Merchant ${merchantId}:`, err); res.status(500).json({ error: 'Failed to delete Merchant.' }); } finally { client.release(); /* <-- GARANTIDO */ } });
router.delete('/items/:id', ensureAuthenticated, async (req, res) => { const itemId = req.params.id; const userId = req.user.user_id; const client = await db.connect(); /* <-- CORRIGIDO */ try { await client.query('BEGIN'); await client.query('DELETE FROM elden_ring_item_locations WHERE item_id = $1', [itemId]); await client.query('DELETE FROM elden_ring_boss_drops WHERE item_id = $1', [itemId]); await client.query('DELETE FROM elden_ring_enemy_drops WHERE item_id = $1', [itemId]); await client.query('DELETE FROM elden_ring_merchant_inventory WHERE item_id = $1', [itemId]); const result = await client.query('DELETE FROM elden_ring_items WHERE item_id = $1 AND user_id = $2', [itemId, userId]); await client.query('COMMIT'); if (result.rowCount > 0) { res.sendStatus(200); } else { await client.query('ROLLBACK'); res.status(404).json({ error: 'Item not found or not owned by user.' }); } } catch (err) { await client.query('ROLLBACK'); console.error(`Erro delete Item ${itemId}:`, err); res.status(500).json({ error: 'Failed to delete Item.' }); } finally { client.release(); /* <-- GARANTIDO */ } });

module.exports = router;